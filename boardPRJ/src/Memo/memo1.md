JPA : ORM 기술 표준으로 사용되는 인터페이스 모음

ORM : 자바 클래스와 RDBMS와 테이블 매핑
- 영속화 : 객체와 테이블은 동일한 데이터를 가진다 = 1:1 매칭 ( 자바 객체1개 = 테이블1개)
- JPA의 역할 : 개발자가 DB를 직접 컨트룰하지 않고, DB와 자바 동기화를 시켜준다
즉 개발자는 자바 객체에 CRUD한다

JPA의 주요 개념
- JPA는 인터페이스이디
JPA의 구현체 hibernate가 함수명을 확인하고 Sql 생성함
즉 인터페이스 함수명만 작성하고 구현하지 않는다
- DB연동 방법은 JDBC를 사용
1차 캐시? 2차 캐시?

JPA 성능 향상 방법 (DB 호출 횟수 줄이기)
- Entity를 통해 CRUD들은 모두 캐시=메모리 저장
단 직접 SQL 호출하는 Native Query 사용
동작과정
- 데이터 조회하여 체크 => DB조회 => DB조회결과 캐시에 저장 => Service 전달
-Entity는 스프링이 시작될 떄 데이터를 저장하지 않고 JPA를 이용하여 변경이 발생할 떄
해당되는 레크만 캐시 저장

JPA의 문제
-동시성 문제 : 싱글코어에서 멀티 스레드를 수행하기 위한 방식
멀티 태스킹을 위해 여러 개의 스레드가 실행
쉽게 말해서 동시에 여러 사용자가 같은 데이터를 사용


	-동시성 문제로 발생되는 문제
		-처리속도, ACID 제공 어려움
	-해결방안
		- 2차 캐시 : 조회 결과를 별도의 객체를 복사해서 제공
		즉 사용자 =>1차 캐시(사용자수정가능)=> 2차 캐시 => DB
        - JPA 트랙잭션 : 초종 수정된 버전을 2차 캐시에 반영하도록하여  트랙잭션을 처리 
        즉 여러 사용자가 1차캐시를 수정해도 2차캐시에 반영되지 않음

JPA의 장점
    - SQL문이 아닌 함수를 통해 CRUD
        hibernates가 함수를 자동으로 sql로 변환
    - 객체지향적 코드 작성이 가능
        개발자는 자바 객체만 제어
    - 데이터 모델링구조가 단순
        JOIN 사용 불가능
    - 데이터베이스 변경이 쉬움

JPA의 단점
    - 데이터 모델링 구조가 복잡한 경우 적용이 어려움
    - 단순 쿼리만 지원하기 때문에 복잡한 수준의 쿼리는 함수로 구현불가
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

프로젝트 실습

DTO : 데이터 전달 및 받기위해 설정
    Entity에 저장된 데이터와 dto의 변수명이 동일해야됨
    또한 JPA는 변수명에 _ 사용 불가능

Entity : 테이블과 1:1 매칭됨
    주요 설정 NotNull 설정
    Entity 객체는 데이터의 CURD 발생 시에 정보가 같이 저장
        - 캐시 역할
        - JPA및 생성자, 빌더를 통해 수정
        - 절대 setter 함수들을 생성하면 안됨 ( 외부의 영향으로 값이 바뀔 수도 있으므로)

Repository : Entity의 값을 CRUD 역할
    findall : 테이블 전체 조회
    find : 단건 조회

    조회종류/정렬조건/조회조건추가
    ex) OrderByNoticeSeqDesc : NoticeSeq 필드를 내림차순 조회(다.나.가 순)

Service
    주요 로직 구현
    JPA의 Repository 실행
    Entity를 DTO로 변환 
        - Entity는 데이터베이스의 테이블과 매칭되는 구조로 사용이 완료되면 바로 반납하는 것이 성능이 좋음

Controller
    전달 받은 데이터를 Service에 전달
    @Controller, RestController 사용
        -Controlelr : MVC 사용 , RestController : 결과를 json 및 string 처리




